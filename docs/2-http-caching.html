<section>
    <h2>HTTP Caching</h2>
    <a
        href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching</a>
    <p>The performance of web sites and applications can be significantly improved by reusing previously fetched
        resources. Web caches reduce latency and network traffic and thus lessen the time needed to display a
        representation of a resource. By making use of HTTP caching, Web sites become more responsive.</p>
</section>
<section>
    <p>Caching is a technique that stores a copy of a given resource and serves it back when requested. When a web cache
        has a requested resource in its store, it intercepts the request and returns its copy instead of re-downloading
        from the originating server. This achieves several goals: it eases the load of the server that doesn’t need to
        serve all clients itself, and it improves performance by being closer to the client, i.e., it takes less time to
        transmit the resource back. For a web site, it is a major component in achieving high performance. On the other
        side, it has to be configured properly as not all resources stay identical forever: it is important to cache a
        resource only until it changes, not longer.</p>
    <p>There are several kinds of caches: these can be grouped into two main categories: private or shared caches. A
        shared cache is a cache that stores responses for reuse by more than one user. A private cache is dedicated to a
        single user. This page will mostly talk about browser and proxy caches, but there are also gateway caches, CDN,
        reverse proxy caches and load balancers that are deployed on web servers for better reliability, performance and
        scaling of web sites and web applications.</p>
    <h2>different kinds of caches</h2>
    <p>Caching is a technique that stores a copy of a given resource and serves it back when requested.</p>
    <p>There are several kinds of caches:</p>
    <ul>
        <li>A shared cache is a cache that stores responses for reuse by more than one user. </li>
        <li>A private cache is dedicated to a single user. </li>
    </ul>
    <p>caches: browser, proxy, gateway, CDN, reverse proxy, load balancer</p>
    <div class="table-layout">
        <div class="table-row">
            <span>caches</span>
            <span>browser</span>
            <span>proxy</span>
            <span>gateway</span>
            <span>CDN</span>
            <span>reverse proxy</span>
            <span>load balancer</span>
        </div>
        <div class="table-row">
            <span>concept</span>
            <span>dedicated to a single user</span>
            <span>stores responses to be reused by more than one user. </span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="table-row">
            <span>private or shared?</span>
            <span>private</span>
            <span>shared</span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="table-row">
            <span>how to deploy?</span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="table-row">
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="table-row">
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="table-row">
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>

    <picture>
        <!-- <source srcset="https://mdn.mozillademos.org/files/13777/HTTPCachtType.png"> -->
        <!-- <img src="https://mdn.mozillademos.org/files/13777/HTTPCachtType.png" alt=""> -->
    </picture>
    <section>
        <h3>privete browser caches</h3>
        <p>A private cache is dedicated to a single user. You might have seen "caching" in your browser's settings
            already. A browser cache holds all documents downloaded via HTTP by the user. This cache is used to make
            visited documents available for back/forward navigation, saving, viewing-as-source, etc. without requiring
            an additional trip to the server. It likewise improves offline browsing of cached content.</p>
    </section>
    <section>
        <h3>shared proxy caches</h3>
    </section>
</section>
<section>
    <h2>targets of caching operations</h2>
    <p>HTTP caching is optional, but reusing a cached resource is usually desirable. </p>
    <p>However, common HTTP caches are typically limited to caching responses to GET and may decline other methods. </p>
    <p> The primary cache key consists of the request method and target URI (oftentimes only the URI is used as only GET
        requests are caching targets).</p>
    <p>Common forms of caching entries are:</p>
    <ul>
        <li>Successful results of a retrieval request: a 200 (OK) response to a GET request containing a resource like
            HTML documents, images or files.</li>
        <li>Permanent redirects: a 301 (Moved Permanently) response.</li>
        <li>Error responses: a 404 (Not Found) result page.</li>
        <li>Incomplete results: a 206 (Partial Content) response.</li>
        <li>Responses other than GET if something suitable for use as a cache key is defined.</li>
    </ul>
    <p>A cache entry might also consist of multiple stored responses differentiated by a secondary key, if the request
        is target of content negotiation. </p>
</section>
<section>
    <h2>controlling caching</h2>
    <section>
        <h3>the cache-control header</h3>
        <p>The Cache-Control HTTP/1.1 general-header field is used to specify directives for caching mechanisms in both
            requests and responses. Use this header to define your caching policies with the variety of directives it
            provides.</p>
        <section>
            <h4>no caching</h4>
            <p>The cache should not store anything about the client request or server response. A request is sent to the
                server and a full response is downloaded each and every time.</p>
            <pre><code>
                Cache-Control: no-store
            </code></pre>
        </section>
        <section>
            <h4>cache but revalidate</h4>
            <p>A cache will send the request to the origin server for validation before releasing a cached copy.</p>
            <pre><code>
                Cache-Control: no-cache
            </code></pre>
        </section>
        <section>
            <h4>private and public caches</h4>
            <p>The "public" directive indicates that the response may be cached by any cache. This can be useful if
                pages with HTTP authentication, or response status codes that aren't normally cacheable, should now be
                cached.</p>
            <p>On the other hand, "private" indicates that the response is intended for a single user only and must not
                be stored by a shared cache. A private browser cache may store the response in this case.</p>
            <pre><code>
                Cache-Control: private
                Cache-Control: public
            </code></pre>
        </section>
        <section>
            <h4>expiration</h4>
            <p>The most important directive here is "max-age=&lt;seconds&gt;" which is the maximum amount of time a
                resource will be considered fresh. Contrary to Expires, this directive is relative to the time of the
                request. For the files in the application that will not change, you can usually add aggressive caching.
                This includes static files such as images, CSS files and JavaScript files, for example.</p>
            <p>max-age=seconds</p>
            <p>the maximum amount of time a resource will be considered fresh.</p>
        </section>
        <section>
            <h4>validation</h4>
        </section>
    </section>
    <section>
        <h3>the pragma header</h3>
        <p>pragma for backwards compatibility with HTTP/1.0 clients</p>
    </section>
</section>
<section>
    <h2>freshness</h2>
    <p>Once a resource is stored in a cache, it could theoretically be served by the cache forever. Caches have finite
        storage so items are periodically removed from storage. This process is called cache eviction. On the other
        side, some resources may change on the server so the cache should be updated. As HTTP is a client-server
        protocol, servers can't contact caches and clients when a resource changes; they have to communicate an
        expiration time for the resource. Before this expiration time, the resource is fresh; after the expiration time,
        the resource is stale. Eviction algorithms often privilege fresh resources over stale resources. Note that a
        stale resource is not evicted or ignored; when the cache receives a request for a stale resource, it forwards
        this request with a If-None-Match to check if it is in fact still fresh. If so, the server returns a 304 (Not
        Modified) header without sending the body of the requested resource, saving some bandwidth.</p>
    <p>Here is an example of this process with a shared cache proxy:</p>
    <p>The freshness lifetime is calculated based on several headers. If a "Cache-control: max-age=N" header is
        specified, then the freshness lifetime is equal to N. If this header is not present, which is very often the
        case, it is checked if an Expires header is present. If an Expires header exists, then its value minus the value
        of the Date header determines the freshness lifetime. Finally, if neither header is present, look for a
        Last-Modified header. If this header is present, then the cache's freshness lifetime is equal to the value of
        the Date header minus the value of the Last-modified header divided by 10.
        The expiration time is computed as follows:</p>
    <pre><code>
            expirationTime = responseTime + freshnessLifetime - currentAge
        </code></pre>
    <p>where responseTime is the time at which the response was received according to the browser.</p>
    <p>Once a resource is stored in a cache, it could theoretically be served by the cache forever. </p>
    <p>Caches have finite storage so items are periodically removed from storage.</p>
    <p>This process is called <i class="keyword">cache eviction</i> n. 逐出；赶出；收回.</p>
    <p>On the other side, some resources may change on the server so the cache should be updated.</p>
    <p>As HTTP is a client-server protocol, servers can't contact caches and clients when a resource changes; they have
        to communicate an expiration time for the resource. </p>
    <p>Before this expiration time, the resource is <i class="keyword">fresh</i>; after the expiration time, the
        resource is <i class="keyword">stale</i> adj.
        陈腐的；不新鲜的.</p>
    <p> Eviction algorithms often privilege fresh resources over stale resources. </p>
    <p> Note that a stale resource is not evicted or ignored; when the cache receives a request for a stale resource, it
        forwards this request with a If-None-Match to check if it is in fact still fresh. If so, the server returns a
        304 (Not Modified) header without sending the body of the requested resource, saving some bandwidth.</p>
    <pre>
        freshness lifetime:

        'Cache-Control: max-age=N'
         |__> yes   
         |__> no   Expires
                        |__> yes    Expires - Date
                        |
                        |__> no   Last-Modified
                                    |__> yes     Date - Last-modified / 10 ?? (Date - Last-modified) / 10
                                    |            
                                    |__> no  

        expirationTime = responseTime + freshnessLifetime - currentAge                     
    </pre>
    <section>
        <h3>revved resources</h3>
        <p>The more we use cached resources, the better the responsiveness and the performance of a Web site will be. To
            optimize this, good practices recommend to set expiration times as far in the future as possible. This is
            possible on resources that are regularly updated, or often, but is problematic for resources that are rarely
            and infrequently updated. They are the resources that would benefit the most from caching resources, yet
            this makes them very difficult to update. This is typical of the technical resources included and linked
            from each Web pages: JavaScript and CSS files change infrequently, but when they change you want them to be
            updated quickly.</p>
        <p>Web developers invented a technique that Steve Souders called revving[1]. Infrequently updated files are
            named in a specific way: in their URL, usually in the filename, a revision (or version) number is added.
            That way each new revision of this resource is considered as a resource on its own that never changes and
            that can have an expiration time very far in the future, usually one year or even more. In order to have the
            new versions, all the links to them must be changed, that is the drawback of this method: additional
            complexity that is usually taken care of by the tool chain used by Web developers. When the infrequently
            variable resources change they induce an additional change to often variable resources. When these are read,
            the new versions of the others are also read.</p>
        <p>This technique has an additional benefit: updating two cached resources at the same time will not lead to the
            situation where the out-dated version of one resource is used in combination with the new version of the
            other one. This is very important when web sites have CSS stylesheets or JS scripts that have mutual
            dependencies, i.e., they depend on each other because they refer to the same HTML elements.</p>
        <p>The revision version added to revved resources doesn't need to be a classical revision string like 1.1.3, or
            even a monotonously growing suite of number. It can be anything that prevent collisions, like a hash or a
            date.</p>
        <p>revving 加快转速</p>
        <p>Infrequently updated files are named in a specific way: in their URL, usually in the filename, a revision (or
            version) number is added.</p>
        <p>drawback: </p>
        <p>additional benefit: </p>
    </section>
</section>
<section>
    <h2>cache calidation</h2>
    <p>When a cached document's expiration time has been reached, it is either validated or fetched again. Validation
        can only occur if the server provided either a <i class="keyword">strong validator</i> or a <i
            class="keyword">weak validator</i>.</p>
    <p>Revalidation is triggered when the user presses the reload button. It is also triggered under normal browsing if
        the cached response includes the "Cache-control: must-revalidate" header. Another factor is the cache validation
        preferences in the Advanced->Cache preferences panel. There is an option to force a validation each time a
        document is loaded.</p>

    <p>When a cached document's expiration time has been reached, it is either validated or fetched again. </p>
    <p>Validation can only occur if the server provided either a strong validator or a weak validator.</p>
    <p>Revalidation is triggered when the user presses the reload button. </p>
    <p>It is also triggered under normal browsing if the cached response includes the "Cache-control: must-revalidate"
        header.</p>
    <p>Another factor is the cache validation preferences in the Advanced--Cache preferences panel.There is an option to
        force a validation each time a document is loaded.</p>

    <section>
        <h3>ETags</h3>
        <p>The ETag response header is an opaque-to-the-useragent value that can be used as a strong validator. That
            means that a HTTP user-agent, such as the browser, does not know what this string represents and can't
            predict what its value would be. If the ETag header was part of the response for a resource, the client can
            issue an If-None-Match in the header of future requests – in order to validate the cached resource.</p>
        <p>The Last-Modified response header can be used as a weak validator. It is considered weak because it only has
            1-second resolution. If the Last-Modified header is present in a response, then the client can issue an
            If-Modified-Since request header to validate the cached document.</p>
        <p>When a validation request is made, the server can either ignore the validation request and response with a
            normal 200 OK, or it can return 304 Not Modified (with an empty body) to instruct the browser to use its
            cached copy. The latter response can also include headers that update the expiration time of the cached
            document.</p>

        <p>The ETag response header is an opaque-to-the-useragent value that can be used as a strong validator. </p>
    </section>
</section>
<section>
    <h2>Varying responses</h2>
    <p>The Vary HTTP response header determines how to match future request headers to decide whether a cached response
        can be used rather than requesting a fresh one from the origin server.</p>
    <p>When a cache receives a request that can be satisfied by a cached response that has a Vary header field, it must
        not use that cached response unless all header fields as nominated by the Vary header match in both the original
        (cached) request and the new request.</p>
    <p>This can be useful for serving content dynamically, for example. When using the Vary: User-Agent header, caching
        servers should consider the user agent when deciding whether to serve the page from cache. If you are serving
        different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version
        of your site to your mobile users. In addition, it can help Google and other search engines to discover the
        mobile version of a page, and might also tell them that no Cloaking is intended.</p>
    <pre><code>
        Vary: User-Agent
    </code></pre>
    <p>Because the User-Agent header value is different ("varies") for mobile and desktop clients, caches will not be
        used to serve mobile content mistakenly to desktop users or vice versa.</p>
</section>
<section>
    <h2></h2>
</section>
<section>
    <h2></h2>
</section>
<section>
    <h2></h2>
</section>
<section>
    <h2></h2>
</section>
<section>
    <h3></h3>
</section>

<section>
    <h4></h4>
</section>